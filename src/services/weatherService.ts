
interface WeatherData {
  temperature: string;
  humidity: string;
  windSpeed: string;
  precipitation: string;
  location: string;
  description?: string;
  pressure?: string;
  visibility?: string;
  cloudCover?: string;
  feelsLike?: string;
  weatherIcon?: string;
  isRealData?: boolean;
}

class WeatherService {
  private apiKey = import.meta.env.VITE_OPENWEATHER_API_KEY;
  private baseUrl = 'https://api.openweathermap.org/data/2.5/weather';
  private lastRealDataTime: Date | null = null;
  private lastSuccessfulLocation: string | null = null;

  async getRealTimeWeatherData(location: 'thies' | 'taiba-ndiaye' | 'hann-maristes' | 'dakar' | 'bargny'): Promise<WeatherData | null> {
    console.log(`üîç DEBUG: D√©but r√©cup√©ration m√©t√©o pour ${location}`);
    console.log(`üîç DEBUG: API Key disponible: ${!!this.apiKey}`);
    
    if (!this.apiKey) {
      console.warn('‚ö†Ô∏è DEBUG: Cl√© API OpenWeather manquante - utilisation donn√©es de secours uniquement');
      const fallbackData = this.getFallbackData(location);
      fallbackData.isRealData = false;
      return fallbackData;
    }

    const cityMapping = {
      'thies': 'Thi√®s,SN',
      'taiba-ndiaye': 'Taiba Ndiaye,SN', 
      'hann-maristes': 'Hann,SN',
      'dakar': 'Dakar,SN',
      'bargny': 'Bargny,SN'
    };

    const cityQuery = cityMapping[location] || 'Thi√®s,SN';
    console.log(`üîç DEBUG: Requ√™te pour ville: ${cityQuery}`);
    
    try {
      const url = `${this.baseUrl}?q=${encodeURIComponent(cityQuery)}&appid=${this.apiKey}&units=metric&lang=fr`;
      console.log(`üåç DEBUG: URL compl√®te: ${url.replace(this.apiKey, 'HIDDEN_API_KEY')}`);
      
      const response = await fetch(url, { 
        headers: {
          'Accept': 'application/json'
        }
      });

      console.log(`üîç DEBUG: Statut r√©ponse: ${response.status}`);
      
      if (!response.ok) {
        console.error(`‚ùå DEBUG: Erreur API: ${response.status} ${response.statusText}`);
        throw new Error(`API Error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      console.log(`üîç DEBUG: Donn√©es API re√ßues:`, data);
      
      // Valider que les donn√©es sont compl√®tes
      if (!data.main || !data.weather || !data.wind) {
        console.error('‚ùå DEBUG: Donn√©es API incompl√®tes:', { main: !!data.main, weather: !!data.weather, wind: !!data.wind });
        throw new Error('Donn√©es API incompl√®tes');
      }

      this.lastRealDataTime = new Date();
      this.lastSuccessfulLocation = location;
      const weatherData = this.formatOpenWeatherData(data);
      
      console.log(`‚úÖ DEBUG: Donn√©es m√©t√©o temps r√©el format√©es avec succ√®s`);
      console.log(`‚úÖ DEBUG: Description finale: ${weatherData.description}`);
      return weatherData;

    } catch (error) {
      console.error(`‚ùå DEBUG: √âchec r√©cup√©ration donn√©es temps r√©el pour ${location}:`, error);
      
      // Utiliser les donn√©es de secours uniquement en cas d'√©chec
      console.log(`üîÑ DEBUG: Basculement vers donn√©es de secours pour ${location}`);
      const fallbackData = this.getFallbackData(location);
      fallbackData.isRealData = false;
      console.log(`üîÑ DEBUG: Donn√©es de secours cr√©√©es avec description: ${fallbackData.description}`);
      return fallbackData;
    }
  }

  private formatOpenWeatherData(data: any): WeatherData {
    console.log(`üîç DEBUG: Formatage donn√©es OpenWeather - description originale: ${data.weather[0].description}`);
    
    // Calcul pr√©cipitations (pluie + neige sur 1h)
    let precipitation = 0;
    if (data.rain?.['1h']) precipitation += data.rain['1h'];
    if (data.snow?.['1h']) precipitation += data.snow['1h'];

    // Utiliser la vraie description m√©t√©o d'OpenWeather
    const realDescription = data.weather[0].description.charAt(0).toUpperCase() + data.weather[0].description.slice(1);
    
    const formattedData = {
      temperature: `${Math.round(data.main.temp)}¬∞C`,
      humidity: `${data.main.humidity}%`,
      windSpeed: `${Math.round(data.wind.speed * 3.6)} km/h`,
      precipitation: `${precipitation.toFixed(1)} mm`,
      location: data.name,
      description: realDescription, // Description r√©elle d'OpenWeather
      pressure: `${data.main.pressure} hPa`,
      feelsLike: `${Math.round(data.main.feels_like)}¬∞C`,
      visibility: data.visibility ? `${(data.visibility / 1000).toFixed(1)} km` : undefined,
      cloudCover: data.clouds ? `${data.clouds.all}%` : undefined,
      weatherIcon: this.getWeatherIcon(data.weather[0].icon),
      isRealData: true // VRAIES donn√©es OpenWeather
    };
    
    console.log(`üîç DEBUG: Donn√©es format√©es - description finale: ${formattedData.description}, isRealData: ${formattedData.isRealData}`);
    return formattedData;
  }

  private getWeatherIcon(iconCode: string): string {
    const iconMapping = {
      "01d": "sun", "01n": "moon",
      "02d": "cloud", "02n": "cloud",
      "03d": "cloud", "03n": "cloud",
      "04d": "cloud", "04n": "cloud",
      "09d": "rain", "09n": "rain",
      "10d": "rain", "10n": "rain",
      "11d": "storm", "11n": "storm",
      "13d": "snow", "13n": "snow",
      "50d": "mist", "50n": "mist"
    };
    return iconMapping[iconCode] || "sun";
  }

  private getFallbackData(location: string): WeatherData {
    console.log(`üîç DEBUG: G√©n√©ration donn√©es de secours pour ${location}`);
    
    const locationNames = {
      'thies': 'Thi√®s',
      'taiba-ndiaye': 'Ta√Øba Ndiaye',
      'hann-maristes': 'Hann Maristes', 
      'dakar': 'Dakar',
      'bargny': 'Bargny'
    };

    // Donn√©es de secours r√©alistes pour la r√©gion
    const currentMonth = new Date().getMonth() + 1;
    const isDrySeason = [11, 12, 1, 2, 3, 4, 5].includes(currentMonth);
    
    // Variation l√©g√®re pour simuler des conditions changeantes
    const tempVariation = Math.floor(Math.random() * 4) - 2;
    const humidityVariation = Math.floor(Math.random() * 10) - 5;
    
    const fallbackData = isDrySeason ? {
      temperature: `${28 + tempVariation}¬∞C`,
      humidity: `${55 + humidityVariation}%`,
      windSpeed: `${12 + Math.floor(Math.random() * 6)} km/h`,
      precipitation: `${(Math.random() * 1.2).toFixed(1)} mm`,
      location: locationNames[location as keyof typeof locationNames] || 'Thi√®s',
      description: 'Donn√©es de secours - Saison s√®che',
      pressure: `${1014 + Math.floor(Math.random() * 8)} hPa`,
      feelsLike: `${30 + tempVariation}¬∞C`,
      visibility: `${10 + Math.floor(Math.random() * 5)} km`,
      cloudCover: `${Math.floor(Math.random() * 30)}%`,
      weatherIcon: 'sun',
      isRealData: false
    } : {
      temperature: `${25 + tempVariation}¬∞C`,
      humidity: `${78 + humidityVariation}%`,
      windSpeed: `${10 + Math.floor(Math.random() * 8)} km/h`,
      precipitation: `${(8 + Math.random() * 15).toFixed(1)} mm`,
      location: locationNames[location as keyof typeof locationNames] || 'Thi√®s',
      description: 'Donn√©es de secours - Saison des pluies',
      pressure: `${1010 + Math.floor(Math.random() * 6)} hPa`,
      feelsLike: `${27 + tempVariation}¬∞C`,
      visibility: `${6 + Math.floor(Math.random() * 4)} km`,
      cloudCover: `${60 + Math.floor(Math.random() * 30)}%`,
      weatherIcon: 'rain',
      isRealData: false
    };
    
    console.log(`üîç DEBUG: Donn√©es de secours g√©n√©r√©es avec description: ${fallbackData.description}`);
    return fallbackData;
  }

  // M√©thode pour donn√©es de secours (legacy)
  async getWeatherData(location: string): Promise<WeatherData> {
    return this.getFallbackData(location);
  }

  isUsingRealData(): boolean {
    if (!this.lastRealDataTime) return false;
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    return this.lastRealDataTime > fiveMinutesAgo;
  }

  getLastSuccessfulLocation(): string | null {
    return this.lastSuccessfulLocation;
  }
}

export const weatherService = new WeatherService();
export type { WeatherData };
